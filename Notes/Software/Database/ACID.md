در ابتدا باید بگیم ترنزکشن چیه؟ ترنزکشن یک مجموعه کوئری که به صورت یه unit of work رفتار میکنه و نمیتونه split بشه. و ترنزکشن یه چرخه داره
- Transaction begin(checkpoint)
- Transaction commit(savepoint)
- Transaction rollback
- Transaction unexpected ending = rollback(Crash)

tx = transaction

---
## Atomicity

این به معنیه که یا همه کار ها انجام میشه یا هیچ کدوم از تغیییرات اعمال نمیشه و اگر حتی یکی از عملیات های یک transaction شکست بخوره کل TX رول بک میشه. یا همه کوئری های داخل یک tx باید موفق باشه.

حالا ممکنه کوئری های ما درست باشه و یهو وسط یه کوئری دیتابیس کرش کنه. اون موقع دیگه ما مقصر نبودیم اصن که. دیتابیس باید بتونه بعد از زیستازت برگرده به حالت صحیح

> lack of atomicity lead to weak consistency

---
## Consistency
این ویژگی میگه بعد از انجام هر تراکنش دیتابیس از یک وضعیت معتبر به یک وضعیت معتبر دیگه میره. مثلا حساب به وضعیت منفی نمیره یا مثلا فیلد FK نباید به سطری که وجود ندارد اشاره کند

[[BASE#ا**Eventual consistency (سازگاری نهایی) **]]

---
## Isolation
این ویژگی برای اینه که TX های ما باید بصورت stateless باشن و نباید روی هم تاثیر بزارن. مثلا اگر دوتا تراکنش بخواد موجودی حساب رو عوض کنن روی هم تاثیری نزارن و تداخلی پیش نیاد. یا به عبارتی دیگر ایا tx من میتونه تغییراتی که توسط tx های دیگر ایجاد شده ببینه؟

[[Isolation Level]]

---
## Durability
پس از موفقیت آمیز بودن یک TX تغییرات باید روی ‌DB حتی در صورت  بروز خطاهای سیستمی اعمال بشن(مثل قطع برق)
به عبارتی دیگر اگر در جواب tx به من گفتی که commit شده دفعه بعدی هم که میام تو db هستش
- دیتابیس ها معمولا اینکارو با کمک **WAL** = Write ahead log انجام میدن یعنی قبل از ایجاد هر تغییر در db ابتدا اون رو در فایل لاگ مینویسن. حالا ممکنه لاگ های ما که تو کش هستن به محض اینکه میخوان برن روی دیسک دیتابیس بترکه. اینجوری دیتابیس فکر میکنه ذخیره شده ولی هیچی ذخیره نشده. اینجا ما میایم کش دیفات رو bypass میکنیم و مستقیم توی دیسک مینویسم([[Cache#Fsync]])
- یه کار دیگه هم که میکنن به صورت async از db انسپ شات میگیرن
- و AOF: خیلی شبیه WALه و تغییرات رو مینویسه